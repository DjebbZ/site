---
layout: default
---

<div class="hero">
  <div class="wrapper">
    <img class="hero-logo" src="/img/cljs-white.svg">
    <div class="hero-title">ClojureScript</div>
    <div class="hero-quote">"Clojure rocks, and JavaScript reaches."</div>
  </div>
</div>

<!--
NOTE: Having trouble squeezing this blurb into the hero section without ruining the design.
      Just give it another section.


What is this?

ClojureScript is a dynamic language that compiles to JavaScript.

Knee-jerk (?) points

- Clojure, a singular vision: The Clojure language introduced simple and
  practical principles to make it a mainstream industry success on the JVM.
  ClojureScript continues this legacy by allowing these principles to reach the
  large and ubiquitous JavaScript platform.
- Embraces JavaScript: ClojureScript is designed at its core to be a guest to
  the JavaScript host platform, meaning easy usage of JS from CLJS and vice
  versa. Start easing CLJS into your codebase today.
- Aggressively Optimized: A fast compiler and runtime tuned for over four years.

Technical Innovation points

- Favor Functional style: pure data and functions in favor of OOP. But when needed,
  simple semantics are provided for imperative styles, polymorphic functions,
  and hierarchical relationships. Schema is here if you need runtime type
  checking too.
- Purity of all values: In JS, numbers and strings are values that can never
  change, thus all operations on them produce new values.  Clojure extends this
  idea to any collection type through a unique innovation, thus all operations
  on them produce new collections (with structural sharing) without incurring
  the usual concerns related to mutation or copying costs.  This truly enables
  a pure functional paradigm that can act consistently for all values.
- Thinking with Values: Clojure's pure representation of values enables constant-time
  equality checks between arbitrarily nested values.  Whereas JS objects can only be keyed
  by numbers or strings, Clojure's maps can be keyed by arbitrary values of any type.
- State: ... (flip book model: don't erase, use the next page)
- Be more expressive: the simple syntax power of an improved Lisp. Everything is
  an expression of the same shape.  Expressions become like LEGO pieces: simple,
  consistent, and easily composable.  (compare to the 2 shapes of the JS if-statements?)
- Meta-programming: the syntax is not only simple, but is known for its unbridled power.
  The syntax can be organically grown through macros.
  The macro is the notorious footgun of Lisp-lore, but they are generally used
  by library developers to give application developers the full power of the
  language.  (Golang's goroutines were added as library!)

External Tech points:

- Google's Production Tools: Though notoriously difficult to use from JS,
  ClojureScript get the benefits of Google's extensive JS production library/compiler
  (coincidentally called "Closure") for free.  The same stuff used by Gmail, Google Maps, etc.
  This gives you the holy grail of size optimization by analyzing your entire
  program and removing code you never use.  Never worry about using large libraries ever again.

- React fully Embraced: 

- Figwheel: The most innovative way to develop with reloadable code.

Why is this different?

How is this better?

* Is it stable? *

-->

<div class="wrapper nosidebar pageContent">
  <div class="inner-content">

      {{ content }}

  </div>
</div>
